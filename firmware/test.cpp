

#define event if
#define await if (true)
#define async
#define local
#define onexit if (true)

async void* val(valLocals& $) {

    local int $diff;

normalWork:

    do {
        event(returnTemp < minReturn - returnHist) {
            goto returnRecover;
        };

        await sleep(delayTime);
        $diff = expectedTemp - outputTemp;
        if ($diff < tempHist) {
            zaw(-1);
        } else {
            zaw(+1);
        }
        await sleep(range(minWorkingTime, workingTime)), $diff * something;
        onexit zaw(0);
    } while (true);

returnRecover:

    do {
        event(returnTemp > minReturn - returnHist) {
            goto normalWork;
        };

        $diff = minReturn - returnTemp;
        if ($diff < 0) {
            zaw(+1);
        } else {
            zaw(-1);
        }

        await sleep(range(minWorkingTime, workingTime)), $diff * something;
        zaw(0);
        await sleep(delayTime);
        onexit zaw(0);

    } while (true);
}

async void* upper(upperLocals& $) {
    local valLocals $val1;
    local valLocals $val2;
    val($val1);
    val($val2);
    await forever();
terminate:
    //val1.terminate(); - will be executed automatically by destructor of valLocals
    //val2.terminate();
}

void delay(int t) {
    local int $timeout;
    $timeout = currentTime() + t;
    state(wait)
    {
        event(currentTime() >= $timeout) {
            goto state(end);
        }
        await forever();
    }
    state(end)
    {
        // just exit
    }
}

void* mainControl() {

    {
        event (boilerTemp >= criticalBoilerTemp) goto boilerCritical;
        event (condition) goto someCode;

        init:
        {
            zaw(0, -1);
            zaw(1, -1);
            zaw(2, -1);
            pomp(0, true);
            pomp(1, false);
            pomp(2, false);
            pomp(3, false);
            //...
            await delay($delayLocal, openTime + openTime / 2);
        }
        leave
        {
            // stuff
        }

        error:
        {
            event (activeErrorCount == 0) {
                goto init;
            }
        }
    }

    boilerCritical:
    {
        event(boilerTemp < criticalBoilerTemp - criticalBoilerHist) {
            goto error; // Autogenerator must track all goto, break and continue statements to call "onexit" and manage locals.
        }
        local valLocals $val1; // Locals will be constructed using new (inplace) operator and destructed using delete (inplace) operator.
        local valLocals $val2; // It will be autogenerated.
        zaw(0, -1);
        pomp(0, true);
        pomp(1, true);
        pomp(2, true);
        pomp(3, true);
        boilerFuel(false);
        boiler(false);
        val($val1, maxFloorTemp, false /* do not protect return */, false /* do not raise error on overtemp */);
        val($val2, maxFloorTemp, false, false);
        activateError(boilerCriticalError);
        await forever();
    }

}
